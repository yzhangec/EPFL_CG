<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Ray Tracer: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ray Tracer
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classMesh.html#a4e9bedfc415b7135c9587f63535fcb6d">Mesh::compute_normals</a>  ()</dt>
<dd>In some scenes (e.g the office scene) some objects should be flat shaded (e.g. the desk) while other objects should be Phong shaded to appear realistic (e.g. chairs). You have to implement the following:<ul>
<li>Compute vertex normals by averaging the normals of their incident triangles.</li>
<li>Store the vertex normals in the <a class="el" href="structMesh_1_1Vertex.html#adf43225146648954d9196e4b6fa47379" title="vertex normal ">Vertex::normal</a> member variable.</li>
<li>Weigh the normals by their triangles' angles.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classMesh.html#a5839749bb09a6bf09c56056016cc11b2">Mesh::intersect_bounding_box</a>  (const <a class="el" href="classRay.html">Ray</a> &amp;_ray) const </dt>
<dd>Intersect the ray <code>_ray</code> with the axis-aligned bounding box of the mesh. Note that the minimum and maximum point of the bounding box are stored in the member variables <code>bb_min_</code> and <code>bb_max_</code>. Return whether the ray intersects the bounding box. This function is ued in <code><a class="el" href="classMesh.html#a3d982c37d43eb5d3929b2de2b263d662">Mesh::intersect()</a></code> to avoid the intersection test with all triangles of every mesh in the scene. The bounding boxes are computed in <code><a class="el" href="classMesh.html#a303c102fd254ea32b366591aa00f6e8e" title="Compute the axis-aligned bounding box, store minimum and maximum point in bb_min_ and bb_max_...">Mesh::compute_bounding_box()</a></code>.  </dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classMesh.html#a9be7264791ff3de7dbf99f8548fb7725">Mesh::intersect_triangle</a>  (const <a class="el" href="structMesh_1_1Triangle.html" title="a triangle is specified by three indices and a normal ">Triangle</a> &amp;_triangle, const <a class="el" href="classRay.html">Ray</a> &amp;_ray, <a class="el" href="classvec3.html">vec3</a> &amp;_intersection_point, <a class="el" href="classvec3.html">vec3</a> &amp;_intersection_normal, double &amp;_intersection_t) const </dt>
<dd><ul>
<li>intersect _ray with _triangle</li>
<li>store intersection point in <code>_intersection_point</code></li>
<li>store ray parameter in <code>_intersection_t</code></li>
<li>store normal at intersection point in <code>_intersection_normal</code>.</li>
<li>Depending on the member variable <code>draw_mode_</code>, use either the triangle normal (<code><a class="el" href="structMesh_1_1Triangle.html#a697c3d7e2f4a316e7b486e048efff56d" title="triangle normal ">Triangle::normal</a></code>) or interpolate the vertex normals (<code><a class="el" href="structMesh_1_1Vertex.html#adf43225146648954d9196e4b6fa47379" title="vertex normal ">Vertex::normal</a></code>).</li>
<li>return <code>true</code> if there is an intersection with t &gt; 0 (in front of the viewer) </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classScene.html#a8c3c270f36a5e73805d925763450de7c">Scene::lighting</a>  (const <a class="el" href="classvec3.html">vec3</a> &amp;_point, const <a class="el" href="classvec3.html">vec3</a> &amp;_normal, const <a class="el" href="classvec3.html">vec3</a> &amp;_view, const <a class="el" href="structMaterial.html">Material</a> &amp;_material)</dt>
<dd>Compute the Phong lighting:<ul>
<li>start with global ambient contribution</li>
<li>for each light source (stored in vector <code>lights</code>) add diffuse and specular contribution</li>
<li>only add diffuse and specular light if object is not in shadow </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classScene.html#aee2e562b23da56880ea30e33f9e76e1b">Scene::trace</a>  (const <a class="el" href="classRay.html">Ray</a> &amp;_ray, int _depth)</dt>
<dd>Compute reflections by recursive ray tracing:<ul>
<li>check whether <code>object</code> is reflective by checking its <code>material.mirror</code></li>
<li>check recursion depth</li>
<li>generate reflected ray, compute its color contribution, and mix it with the color computed by local Phong lighting (use <code>object-&gt;material.mirror</code> as weight)</li>
<li>check whether your recursive algorithm reflects the ray <code>max_depth</code> times </li>
</ul>
</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
